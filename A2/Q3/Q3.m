close all; clear;
I = imread('james.jpg');
J = I(:,:,2);%take the green channel
green = mat2gray(J);%grayscale
imwrite(green, 'green_only.jpg');

sigma = 1; gfilter = imgaussfilt(green,sigma);

yld = conv2(gfilter, [1 1 1; 0 0 0; -1 -1 -1],'same');%local difference in y
xld = conv2(gfilter, [1 0 -1; 1 0 -1; 1 0 -1],'same');%local difference in x

magnitude = sqrt(double(xld.^2+yld.^2));%calculate gradient magnitude
orientation = atan(yld ./ xld);%calculate gradient orientation
binary = double(magnitude > 0.3);%choose the threshold


[yloc, xloc] = find(binary == 1);
%find all the x-y locations

theta = zeros(1,1);
[p,q] = size(xloc);%find the number of locations

for k = 1:p%iterate through the locations and find the corresponding orientation
    theta(k,:) = orientation(xloc(k), yloc(k));
end

T = 100;%number of iteration
tr = 10;
tr_ori = 0.08*pi;
%threshold to decide whether is an inlier/outlier
best = [0,0,0,0,0]; 
%first two values represent location of E, the choosen point in the best edge, 3rd and 4th value
%represent theta and R for the model M, last value represent count of the number of inliers.
for j = 1:T
    count = 0;%initialize count to 0
    
    %generate a random index and find the corresponding x,y,orientation
    rand_index = randi(p);
    rand_x = xloc(rand_index); 
    rand_y = yloc(rand_index);
    rand_ori = theta(rand_index) + 0.5*pi;
    
    %line equation given by R = x*cos(theta)+y*sin(theta)
    R = rand_x*cos(rand_ori) + rand_y*sin(rand_ori);
    
    for k = 1:p
        %loop through every other edge point E* and count number of inliers
        x = xloc(k);
        y = yloc(k);
        ori = theta(k);
        
        %if the absolute difference between R generated by E and R generated by E*
        %is smaller than threshold tr, and the absolute difference between
        %the orientations is smaller than tr_ori, then increment count by 1
        if abs(x*cos(rand_ori) + y*sin(rand_ori) - R) <= abs(tr) && ...
                (abs(abs(rand_ori) - abs(ori)) < abs(tr_ori))
            count = count + 1;
        end
    end
    
    %if count is greater than the count of the best edges, then this is the
    %new best model, update the values stored in the best array
    if count > best(5)
        best = [rand_x,rand_y,rand_ori,R,count];
    end
end

%get the value of R and rand_ori from the best edge
R = best(4);
rand_ori = best(3);

best_inliers = zeros(1,2); best_outliers = zeros(1,2);
%initialize two matrices

i = 1; j = 1;
for k = 1:p%loop through every other edge E*
        x = xloc(k);
        y = yloc(k);
        ori = theta(k);
        
        %store the inliers and outliers into the matrices
        if abs(x*cos(rand_ori) + y*sin(rand_ori) - R) <= abs(tr) && ...
                (abs(abs(rand_ori) - abs(ori)) < abs(tr_ori))
            best_inliers(k,:)= [x,y];
            i = i+1;
        else
            best_outliers(j,:)= [x,y];
            j = j+1;
        end
end


%xy plot
figure(1)
subplot(1,1,1); title('RANSAC'); 
hold on
scatter(best_outliers(:,1),512-best_outliers(:,2),0.5,'black');
scatter(best_inliers(:,1),512-best_inliers(:,2),0.5,'red');

    
        
